{{#if disclaimer}}<!-- {{{ disclaimer }}}{{#if header}}
{{{header}}}{{/if}} -->{{/if}}

<template>
  <v-container>
    <v-row>
      <v-col>
        <h2>{{{curlyOpen}}}{{{curlyOpen}}} adminTitle() {{{curlyClose}}}{{{curlyClose}}}</h2>
        <b v-if="messageExists('title_{{name}}_admin_details', messages)">
          {{{curlyOpen}}}{{{curlyOpen}}} messages.title_{{name}}_admin_details {{{curlyClose}}}{{{curlyClose}}}
        </b>
      </v-col>
    </v-row>
    <div>
      <v-row v-if="addingObject">
        <v-col>
          <OrmForm
            v-if="allRefsLoaded() && {{name}}TypeDef"
            form-name="add_{{name}}_form"
            :type-def="{{name}}TypeDef"
            :type-name-message="typeNameMessage"
            :thing="addObject"
            :fields="{{name}}TypeDefFields"
            :create="true"
            :read-only-object="() => false"
            :server-errors="create{{Name}}ServerErrors"
            :label-prefixes="['admin_label_{{name}}_', 'label_']"
            :hint-suffixes="['_description']"
            @submitted="onAddSubmitted"
            @update="onAddUpdated"
            @cancel="onAddCancel"
          />
        </v-col>
      </v-row>
      <v-row v-else-if="Object.keys(editingObject).length > 0">
        <v-col>
          <OrmForm
            v-if="allRefsLoaded() && {{name}}TypeDef"
            form-name="edit_{{name}}_form"
            :type-def="{{name}}TypeDef"
            type-name-message="typeNameMessage"
            :thing="editingObject"
            :fields="{{name}}TypeDefFields"
            :create="false"
            :read-only-object="() => false"
            :server-errors="edit{{Name}}ServerErrors"
            :label-prefixes="['admin_label_{{name}}_', 'label_']"
            :hint-suffixes="['_description']"
            @submitted="onEditSubmitted"
            @update="onEditUpdated"
            @cancel="onEditCancel"
          />
        </v-col>
      </v-row>
      <v-row v-else-if="allRefsLoaded() && {{name}}TypeDef">
        <v-col>
          <v-container>
            <v-row v-if="{{name}}List && {{name}}List.length > 0">
              <v-col>
                <div>
                  <v-form @submit.prevent="searchObjects">
                    <div class="form-group">
                      <v-text-field
                        v-model="searchTerms"
                        :label="messages.label_search"
                        type="text"
                        name="searchTerms"
                        class="form-control"
                        @keyup.enter="searchObjects"
                      />
                      <v-btn class="btn btn-primary" :disabled="{{name}}Store.{{name}}Busy" @click.stop="searchObjects">
                        <Icon name="material-symbols:search" />
                      </v-btn>
                    </div>
                  </v-form>
                </div>
              </v-col>
            </v-row>
            <v-row>
              <v-col>
                <table v-if="{{name}}List && {{name}}List.length > 0">
                  <thead>
                  <tr>
                    <th v-for="(tableField, tableFieldIndex) in tableFields" :key="tableFieldIndex">
                      {{{curlyOpen}}}{{{curlyOpen}}} tableFieldMessages[tableField] {{{curlyClose}}}{{{curlyClose}}}
                    </th>
                    <th v-if="Object.keys(actionConfigs).length > 0">
                      <Icon name="material-symbols:target" />
                    </th>
                    <th></th>
                    <th></th>
                  </tr>
                  </thead>
                  <tbody>
                  <tr v-for="(obj, objIndex) in {{name}}List" :key="objIndex">
                    <td v-for="(fieldName, fieldIndex) in tableFields" :key="fieldIndex">
                      <OrmFieldDisplay v-if="{{name}}TypeDef.fields[fieldName] || fieldName.startsWith('_meta')" :field="fieldName.startsWith('_meta') ? metaField(fieldName) : {{name}}TypeDef.fields[fieldName]" :value="deepGet(obj, fieldName)" />
                    </td>
                    <td v-if="Object.keys(actionConfigs).length > 0">
                      <div v-for="(action, actionIndex) in Object.keys(actionConfigs)" :key="actionIndex">
                        <NuxtLink
                          v-if="actionEnabled(obj, action)"
                          :to="{ path: `${actionConfig(action).path}/${deepGet(obj, {{name}}TypeDef.idField(obj) as string)}` }"
                        >
                          <v-btn>
                            {{{curlyOpen}}}{{{curlyOpen}}} messages[actionConfig(action).message] {{{curlyClose}}}{{{curlyClose}}}
                          </v-btn>
                        </NuxtLink>
                      </div>
                    </td>
                    <td>
                      <v-btn v-if="canEdit(obj)" :disabled="{{name}}Store.{{name}}Busy" @click.stop="showEditOrm(obj)">
                        <Icon name="material-symbols:edit" />
                      </v-btn>
                    </td>
                    <td>
                      <v-btn v-if="canDelete(obj)" :disabled="{{name}}Store.{{name}}Busy" @click.stop="delObject(obj)">
                        <Icon name="material-symbols:delete" />
                      </v-btn>
                    </td>
                  </tr>
                  </tbody>
                </table>
              </v-col>
            </v-row>
            <v-row>
              <v-col>
                <v-btn class="btn btn-primary" :disabled="{{name}}Store.{{name}}Busy" @click.stop="showAddOrm">
                  <Icon name="material-symbols:add" />
                </v-btn>
              </v-col>
            </v-row>
          </v-container>
        </v-col>
      </v-row>
      <v-row v-else>
        <v-col>
          <Icon name="material-symbols:clock-outline" />
        </v-col>
      </v-row>
    </div>
  </v-container>
</template>

<script setup lang="ts">
  import { ref, Ref } from "vue";
  import { storeToRefs } from "pinia";
  import {
    MobilettoOrmFieldDefConfig,
    MobilettoOrmObject,
    MobilettoOrmTypeDef,
    MobilettoOrmValidationErrors,
    metaField
  } from "mobiletto-orm-typedef";
  import { {{Name}}Type, {{Name}}TypeDef } from "yuebing-model";
  import { fieldErrorMessage, findMessage, messageExists, parseMessage } from "yuebing-messages";
  import { deepUpdate, deepGet } from "~/utils/util";
  import { normalizeMsg } from "~/utils/orm";
  import { useSessionStore } from "~/stores/session";
  import { use{{Name}}Store } from "~/stores/model/{{name}}Store";{{#if typeDef.refTypes}}{{#each typeDef.refTypes}}
  import { use{{RefType}}Store } from "~/stores/model/{{refType}}Store";{{/each}}{{/if}}

  type ActionConfig = {
    path: string;
    message: string;
    when: (obj: MobilettoOrmObject) => boolean;
  };

  const props = withDefaults(
    defineProps<{
      labelPrefixes: string[];
      typeNameMessage: string,
      actionConfigs: Record<string, ActionConfig>;
      canEdit: (obj: MobilettoOrmObject) => boolean;
      canDelete: (obj: MobilettoOrmObject) => boolean;
      deleteConfirmationMessage: string;
    }>(),{
      labelPrefixes: () => ["label_", ""],
      typeNameMessage: () => "typename_{{name}}",
      actionConfigs: () => ({}),
      canEdit: () => true,
      canDelete: () => true,
    },
  );

  const sessionStore = useSessionStore();
  const { localeMessages } = storeToRefs(sessionStore);
  const messages = localeMessages;
  const msg = (key: string, ctx: Record<string, unknown>) => parseMessage(messages.value[key], messages.value, ctx);

  const adminTitle = () => messageExists("admin_title_{{name}}_administration", messages.value)
    ? messages.value.admin_title_{{name}}_administration
    : parseMessage("admin_title_site_administration", messages.value, { title: findMessage(props.typeNameMessage, messages.value, [""])});

  const addingObject = ref(false);
  const addObject = ref({} as {{Name}}Type);
  const create{{Name}}ServerErrors = ref({} as MobilettoOrmValidationErrors);

  const editingObject = ref({} as {{Name}}Type);
  const edit{{Name}}ServerErrors = ref({} as MobilettoOrmValidationErrors);

  const pageNumber = ref(1);
  const pageSize = ref(20);
  const searchTerms = ref("");
  const lastQuery = ref({});

  const searchQuery = () => ({
    pageNumber: pageNumber.value,
    pageSize: pageSize.value,
    searchTerms: searchTerms.value,
  });

  const tableFields: Ref<string[]> = ref([]);

  const tableFieldMessages: Ref<Record<string, string>> = ref({});
  const initTableFieldMessages = (tableFields: string[]) => {
      const defaultTableFieldMessages: Record<string, string> = {};
      tableFields.forEach((f: string) => {
        defaultTableFieldMessages[f] = findMessage(normalizeMsg(f), messages.value, props.labelPrefixes);
      });
      tableFieldMessages.value = defaultTableFieldMessages;
  };
  const searchObjects = () => {
    if (lastQuery.value && JSON.stringify(lastQuery.value) === JSON.stringify(searchQuery())) {
      // console.log("not sending duplicate search");
    } else {
      const query = searchQuery();
      lastQuery.value = Object.assign({}, query);
      // console.log(`searchObjects: emitting query: ${JSON.stringify(query)}`);
      // emit("query", query);
    }
  };

  const fieldError = (field: string, error: any, labelPrefix = "label_") => {
    return field && error ? fieldErrorMessage(field, error, messages.value, labelPrefix) : "(no message)";
  };

  const {{name}}Store = use{{Name}}Store();
  const { {{name}}List  } = storeToRefs({{name}}Store);

  const {{name}}TypeDef: Ref<MobilettoOrmTypeDef | null> = ref(null);
  const {{name}}TypeDefFields: Ref<MobilettoOrmFieldDefConfig[] | undefined> = ref(undefined);

  {{#if typeDef.refTypes}}
  const navigating = ref(false);

  const initTypeDef = () => {
    const typeDef = {{Name}}TypeDef.extend({
      fields: {
      {{#each typeDef.refTypes}}{{#each fieldPaths}}
        {{this}}: { ...ref{{../RefType}}.value },
      {{/each}}{{/each}}
      }
    });
    {{name}}TypeDefFields.value = typeDef.tabIndexedFields();
    {{name}}TypeDef.value = typeDef;
    tableFields.value = {{name}}TypeDef.value.tableFields && Array.isArray({{name}}TypeDef.value.tableFields)
      ? {{name}}TypeDef.value.tableFields
      : {{name}}TypeDef.value.primary
        ? [{{name}}TypeDef.value.primary, "ctime", "mtime"]
        : ["id", "ctime", "mtime"];
    initTableFieldMessages(tableFields.value);
  }

  const allRefs: Ref<Boolean>[] = [];
  const allRefsLoaded = () => allRefs.length === {{typeDef.refTypes.length}} && allRefs.filter(r => r.value === true).length === {{typeDef.refTypes.length}};{{#each typeDef.refTypes}}
  const ref{{RefType}} = ref({} as MobilettoOrmFieldDefConfig);
  const ref{{RefType}}Loaded = ref(false);
  allRefs.push(ref{{RefType}}Loaded);
  const {{refType}}Store = use{{RefType}}Store();
  const { {{refType}}List } = storeToRefs({{refType}}Store);

  watch({{refType}}List, (newList) => {
    if (newList && newList.length === 0) {
      if (navigating.value) return;
      navigating.value = true;
      navigateTo("/admin/{{refType}}/setup");
    } else if (newList && newList.length > 0) {
      ref{{RefType}}.value.values = newList.map((s) => s.name);
      ref{{RefType}}.value.labels = newList.map((s) => s.name);
      ref{{RefType}}.value.items = newList.map((s) => ({
        label: s.name,
        value: s.name,
        title: s.name,
        rawLabel: true,
      }));
    {{#each fieldPaths}}
      addObject.value.{{this}} = ref{{../RefType}}.value.values as any;
    {{/each}}
      ref{{RefType}}Loaded.value = true;
      if (allRefsLoaded()) {
        initTypeDef()
      }
    }
  });
  {{/each}}{{else}}
  const allRefsLoaded = () => true;
  {{name}}TypeDef.value = {{Name}}TypeDef;
  {{name}}TypeDefFields.value = {{Name}}TypeDef.tabIndexedFields();
  tableFields.value = {{name}}TypeDef.value.tableFields && Array.isArray({{name}}TypeDef.value.tableFields)
    ? {{name}}TypeDef.value.tableFields
    : {{name}}TypeDef.value.primary
      ? [{{name}}TypeDef.value.primary, "ctime", "mtime"]
      : ["id", "ctime", "mtime"];
  initTableFieldMessages(tableFields.value);
  {{/if}}

  const onAddUpdated = (update: { field: string; value: any }) => {
    deepUpdate(addObject.value, update.field, update.value);
  };
  const onAddSubmitted = (obj: MobilettoOrmObject) => {
    return {{name}}Store
      .create(obj as {{Name}}Type, create{{Name}}ServerErrors)
      .then(() => {{name}}Store.search());
  }
  const showAddOrm = () => {
    addingObject.value = true;
  };
  const onAddCancel = () => {
    addingObject.value = false;
  };

  const onEditUpdated = (update: { field: string; value: any }) => {
    if (editingObject.value) {
      deepUpdate(editingObject.value, update.field, update.value);
    }
  };

  const onEditSubmitted = (obj: MobilettoOrmObject) => {
    return {{name}}Store
      .update(obj as {{Name}}Type, edit{{Name}}ServerErrors)
      .then(() => {{name}}Store.search());
  }

  const showEditOrm = (obj: MobilettoOrmObject) => {
    if (Object.keys(editingObject.value).length > 0) {
      // already editing something else
      return;
    }
    if (obj) {
      const id = {{Name}}TypeDef.id(obj);
      if (id && id.length > 0) {
        editingObject.value = JSON.parse(JSON.stringify(obj)) as {{Name}}Type;
        // emit("editObjectStart", editingObject.value);
      }
    }
  };
  const onEditCancel = () => {
    editingObject.value = {} as {{Name}}Type;
  };

  const actionConfig = (action: string) => {
    return props.actionConfigs[action];
  };

  const actionEnabled = (obj: MobilettoOrmObject, action: string) => {
    const cfg = props.actionConfigs[action];
    if (!cfg.when || typeof cfg.when !== "function") {
      return true;
    }
    if (typeof cfg.when === "function") {
      return cfg.when(obj) === true;
    }
    return true;
  };

  const deleteConfirmCount = ref(0);
  const JUST_STOP_ASKING_ABOUT_CONFIRMING_DELETION = 3;
  const delObject = (obj: MobilettoOrmObject) => {
    if (!{{name}}TypeDef.value) return;
    if (
      deleteConfirmCount.value > JUST_STOP_ASKING_ABOUT_CONFIRMING_DELETION ||
      confirm(
        msg(props.deleteConfirmationMessage, {
          id: obj ? deepGet(obj, {{name}}TypeDef.value.idField(obj) as string) : null,
        }),
      )
    ) {
      deleteConfirmCount.value++;
      // emit("deleteObject", obj);
    } else {
      deleteConfirmCount.value = 0;
    }
  };

  watch({{name}}List, (newList, _oldList) => {
    if (newList && Array.isArray(newList)) {
      // if ((!oldList && newList.length > 0) || (oldList && oldList.length && oldList.length < newList.length)) {
      //   navigateTo("/admin/{{name}}/setup");
      // }
    }
  });

  {{name}}Store.search(){{#if typeDef.refTypes}}.then((objs) => {
    if (objs.length === 0) { {{#each typeDef.refTypes}}
      {{refType}}Store.search();{{/each}}
    }
  }){{/if}};
</script>
